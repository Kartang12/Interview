SQL

Create
Drop
Alter
Update


DROP TABLE <table_name>

#Alter
ALTER TABLE <t_name> ADD <col_name> <data_type>
					 DROP column <col_name>
					 ALTER COLUMN <col_name> <data_type>
					 ADD CONSTRAINT


#Create
CREATE TABLE Odrers
(
	order_id INT PRIMARY KEY,
	prod_id INT NOT NULL,
	quantity INT,

		CONSTRAINT fr_prod_id
		FOREIGN KEY (prod_id)
		REFERENCES product (prod_id)
#			on DELETE CASCADE
);


#VIEW

CREATE VIEW VW_Odreds AS
SELECT * FROM Odrers; 

INSERT INTO t_name (col_1, col_2) AS 
SELECT name_1, name_2 FROM t_name2;


UPDATE t_name SET col_Name='New Name', col_Name_2 = 'New Name 2' WHERE id=1 
я



#SELF JOIN
Обязательно дать элиасы таблицам

#CROSS JOIN
каждая строка к каждой строке (5 строк в 1 таблице, 6 во второй => 30 строк в итоге)

#PROCEDURES

CREATE PROCEDURE p_name
@Param 	nvarchar(20)
AS
SELECT * FROM t_name
WHERE id = @Param
#GO - чтобы убедиться, что код выше выполнен

EXEC p_name @Param = 5


#INDEX
CREATE INDEX index_name
ON t_name(col_name1, col_name2)

#Много времени на создание
#Порядок полей роляет. Если индекс по 2 полям, то сперва упорядочивается по 1 полю, а потом по второму

#TRANSACTION

CREATE PROCEDURE p_name
@Param 	nvarchar(20)
AS
BEGIN TRY
	BEGIN TRANSACTION

	<SELECT, INSERT, UPDATE...>

	COMMIT TRANSACTION
END TRY

BEGIN CATCH
	ROLLBACK TRANSACTION
END CATCH

SELECT * FROM t_name
WHERE id = @Param


наекластерный индекс можно представить как отдельную таблицу, каждая строка в которой ссылается на одну или несколько строк в таблице с данными. Строки в индексной таблице упорядочены и сгруппированы по значениям ключевых полей.

Плюсы
задача поиска сильно ускоряется. 
Во-первых, индексная таблица весит много меньше таблицы с данными, а значит элементарно может быть прочитана быстрее. 
Во-вторых, СУБД чаще всего стараются кешировать индексы в оперативную память, которая сама по себе много шустрее жёсткого диска*. 
В-третьих, в индексах отсутствуют дублирующиеся строки. А значит, как только мы нашли первое значение, поиск можно прекращать — оно же и последнее. 
В-четвёртых, данные в индексе отсортированы. 
А в-третьих и в-четвёртых вместе позволяют использовать алгоритм бинарного поиска (он же метод деления пополам), эффективность которого многократно превосходит простой перебор.

Кластерный индекс — это древовидная структура данных, при которой значения индекса хранятся вместе с данными, им соответствующими. И индексы, и данные при такой организации упорядочены. При добавлении новой строки в таблицу, она дописывается не в конец файла*, не в конец плоского списка, а в нужную ветку древовидной структуры, соответствующую ей по сортировке.



Очередность полей в индексе

https://dba.stackexchange.com/questions/48458/does-the-order-of-columns-in-a-pk-index-matter/48472

По умолчанию ограничение первичного ключа применяется в SQL Server с помощью уникального кластеризованного индекса. Кластерный индекс определяет логический порядок строк в таблице. Может быть добавлено несколько дополнительных индексных страниц для представления верхних уровней индекса бинарного-дерева, но самый нижний (конечный) уровень кластеризованного индекса — это просто логический порядок самих данных.

Чтобы было ясно, строки на странице не обязательно физически хранятся в порядке ключа кластеризованного индекса. На странице существует отдельная структура косвенного обращения, в которой хранится указатель на каждую строку. Эта структура сортируется по ключам кластеризованного индекса. Кроме того, каждая страница имеет указатель на предыдущую и следующую страницы того же уровня в порядке ключей кластеризованного индекса.

С кластеризованным первичным ключом (RowNumber, DataDate) строки логически сортируются сначала по RowNumber, а затем по DataDate, поэтому все строки, где RowNumber = 1, логически группируются вместе, затем строки, где RowNumber = 2, и так далее.

Когда вы добавляете новые данные (с RowNumbers от 1 до n), новые строки логически принадлежат существующим страницам, поэтому SQL Server, вероятно, придется проделать большую работу, разбивая страницы, чтобы освободить место. Вся эта деятельность создает много дополнительной работы (включая регистрацию изменений) без какой-либо выгоды.

Разделенные страницы также начинаются примерно на 50% пустыми, поэтому чрезмерное разделение также может привести к низкой плотности страниц (меньшее количество строк, чем оптимальное значение для каждой страницы). Мало того, что это плохая новость для чтения с диска (меньшая плотность = больше страниц для чтения), страницы с меньшей плотностью также занимают больше места в памяти при кэшировании.

Изменение кластеризованного индекса на (DataDate, RowNumber) означает, что новые данные (предположительно с более высокими значениями DataDates, чем те, которые хранятся в настоящее время) добавляются к логическому концу кластеризованного индекса на новых страницах. Это устранит ненужные накладные расходы на разбиение страниц и ускорит загрузку. Менее фрагментированные данные также означают, что упреждающее чтение (чтение страниц с диска непосредственно перед тем, как они потребуются для выполняемого запроса) может быть более эффективным.