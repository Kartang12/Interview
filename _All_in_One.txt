
Таблица виртуальных методов
специальная структура в памяти, генерируемая автоматически, в ней перечислены указатели на виртуальные методы. Если где-то в коде вызывается метод function() применительно к указателю на класс A, вместо вызова непосредственно функции A::function() будет произведён вызов функции, находящейся в таблице виртуальных методов по нужному смещению – это поведение реализует полиморфизм.

если вызываемый метод невиртуальный, то он ищется в таблице методов compile-time типа, то есть среди методов того типа, которым является ссылка, через которую мы вызываем метод.
Если же вызывается виртуальный метод, то конкретная его реализация ищется в таблице методов run-time типа, то есть того типа объекта, на который реально указывается ссылка:

для вызова метода в IL метод callvirt. Он реализует принцип позднего связывания. То есть, говоря простым языком, решение о вызове определённого метода принимается во время выполнения, а не компиляции. Тем самым реализуется идея полиморфизма. 





++++++++++++++++++++++++++++++++++++++++++++





Модификаторы доступа


Модификаторы доступа:

public: 
публичный, общедоступный класс или член класса. Такой член класса доступен из любого места в коде, а также из других программ и сборок.

private:
закрытый класс или член класса. Представляет полную противоположность модификатору public. Такой закрытый класс или член класса доступен только из кода в том же классе или контексте.

protected: 
такой член класса доступен из любого места в текущем классе или в производных классах. При этом производные классы могут располагаться в других сборках.

internal: 
класс и члены класса  доступны из любого места кода в той же сборке, однако он недоступен для других программ и сборок (как в случае с модификатором public).

protected internal: 
совмещает функционал двух модификаторов. Классы и члены класса доступны из текущей сборки и из производных классов В другой сборке.

private protected: 
такой член класса доступен из любого места в текущем классе или в производных классах, которые определены в той же сборке.




++++++++++++++++++++++++++++++++++++++++++++
++++++++++++++++++++++++++++++++++++++++++++



Abstract, Interface, Сокрытие, переопределение

Абстрактный класс - создает функционал, который могут реализовывать или переопределять наследники.
Интерфейс - определяет функционал, но не реализует его.

Можно наследовать только 1 класс, но много интерфейсов.

1. В abstract может быть реализация методово и свойств. В interface только сигнатура метода.
2. Abstract может содержать поля
3. Abstract может наследоваться от abstract и interface. Interface - только от Interface



Сокрытие если
метод в базовом классе не является виртуальным, мы не можем его переопределить, но нас не устраивает его реализация для производного класса

Переопределение (virtual)

Person tom = new Employee("Tom", "Microsoft");
tom.Display(); 
вызове tom.Display() выполняется реализация метода Display из класса Employee.

Сокрытие
при вызове метода Display будет выполняться та версия метода, которая определена именно в классе Person, а не в классе Employee.



++++++++++++++++++++++++++++++++++++++++++++





Boxing / Unboxing

Упаковка (boxing) предполагает преобразование объекта значимого типа (например, типа int) к типу object. При упаковке общеязыковая среда CLR обертывает значение в объект типа System.Object и сохраняет его в управляемой куче (хипе). 
Распаковка (unboxing), наоборот, предполагает преобразование объекта типа object к значимому типу. Упаковка и распаковка ведут к снижению производительности, так как системе надо осуществить необходимые преобразования.

Кроме того, существует другая проблема - проблема безопасности типов. Так, мы получим ошибку во время выполнения программы, если напишем следующим образом:

Account account2 = new Account { Sum = 4000 };
account2.Id = "4356";
int id2 = (int)account2.Id;     // Исключение InvalidCastException

Мы можем не знать, какой именно объект представляет Id, и при попытке получить число в данном случае мы столкнемся с исключением InvalidCastException.



++++++++++++++++++++++++++++++++++++++++++++



Delegates, Events, ковариантность, контрвариантность

    // Объявляем делегат
    public delegate void AccountStateHandler(string message);
    // Создаем переменную делегата
    AccountStateHandler _del;

    // Регистрируем делегат
    public void RegisterHandler(AccountStateHandler del)
    {
        _del = del;
    }


    static void Main(string[] args)
    {
        Account account = new Account(200);
        account.RegisterHandler(new Account.AccountStateHandler(Show_Message)); <---------------
        account.Withdraw(100);
        account.Withdraw(150);
        Console.ReadLine();
    }
    private static void Show_Message(String message)	<----------------
    {
        Console.WriteLine(message);
    }



Action
Делегат Action является обобщенным, принимает параметры и возвращает значение void:

public delegate void Action<T>(T obj)


Predicate
Делегат Predicate<T>, как правило, используется для сравнения, сопоставления некоторого объекта T определенному условию. В качестве выходного результата возвращается значение true, если условие соблюдено, и false, если не соблюдено:

Predicate<int> isPositive = delegate (int x) { return x > 0; };
 
Console.WriteLine(isPositive(20));
Console.WriteLine(isPositive(-20));


Func
Он возвращает результат действия и может принимать параметры. Он может принимать до 16 параметров, последний (17) - выходной.

TResult Func<out TResult>()
TResult Func<in T, out TResult>(T arg)



Ковариантность позволяет возвращать из метода объект, тип которого является производным от типа, возвращаемого делегатом
Контрвариантность предполагает возможность передавать в метод объект, тип которого является более универсальным по отношению к типу параметра делегата. 


Event

class Account
{
    public delegate void AccountHandler(string message);
    public event AccountHandler Notify;              // 1.Определение события	<-------------------
    public Account(int sum)
    {
        Sum = sum;
    }
    public int Sum { get; private set;}
    public void Put(int sum)    
    {
        Sum += sum;
        Notify?.Invoke($"На счет поступило: {sum}");   // 2.Вызов события 	<---------------------
    }
    public void Take(int sum)
    {
        if (Sum >= sum)
        {
            Sum -= sum;
            Notify?.Invoke($"Со счета снято: {sum}");   // 2.Вызов события
        }
        else
        {
            Notify?.Invoke($"Недостаточно денег на счете. Текущий баланс: {Sum}"); ;
        }
    }
}


class Program
{
    static void Main(string[] args)
    {
        Account acc = new Account(100);

        acc.Notify += DisplayMessage;   // Добавляем обработчик для события Notify	<---------------

        acc.Put(20);    // добавляем на счет 20
        Console.WriteLine($"Сумма на счете: {acc.Sum}");
        acc.Take(70);   // пытаемся снять со счета 70
        Console.WriteLine($"Сумма на счете: {acc.Sum}");
        acc.Take(180);  // пытаемся снять со счета 180
        Console.WriteLine($"Сумма на счете: {acc.Sum}");
        Console.Read();
    }
    private static void DisplayMessage(string message)					<-------------------
    {
        Console.WriteLine(message);
    }
}




++++++++++++++++++++++++++++++++++++++++++++




IEnumerable

основной для большинства коллекций
Перебираемая коллекция должна реализовать интерфейс IEnumerable.

Интерфейс IEnumerable имеет метод, возвращающий ссылку на другой интерфейс - перечислитель:
IEnumerator GetEnumerator();


А интерфейс IEnumerator определяет функционал для перебора внутренних объектов в контейнере:

public interface IEnumerator
{
    bool MoveNext(); // перемещение на одну позицию вперед в контейнере элементов
    object Current {get;}  // текущий элемент в контейнере
    void Reset(); // перемещение в начало контейнера
}


Метод MoveNext() перемещает указатель на текущий элемент на следующую позицию в последовательности. Если последовательность еще не закончилась, то возвращает true. Если же последовательность закончилась, то возвращается false.

Свойство Current возвращает объект в последовательности, на который указывает указатель.

Метод Reset() сбрасывает указатель позиции в начальное положение.


static void Main(string[] args)
        {
            int[] numbers = { 0, 2, 4, 6, 8, 10 };
 
            IEnumerator ie = numbers.GetEnumerator(); // получаем IEnumerator
            while (ie.MoveNext())   // пока не будет возвращено false
            {
                int item = (int)ie.Current;     // берем элемент на текущей позиции
                Console.WriteLine(item);
            }
            ie.Reset(); // сбрасываем указатель в начало массива
            Console.Read();
        }



++++++++++++++++++++++++++++++++++++++++++++




Коллекции

Необобщенные коллекции
Необобщенные или универсальные коллекции определены в пространстве имен System.Collection.Generic. Самые популярные из этого пространства имен – в списке ниже:

List – класс коллекции, предоставляющий доступ к элементам по индексу. Содержит методы изменения коллекции, сортировки элементов и поиска по элементам.
Dictionary – класс коллекции, в основе которой лежат пара ключ/значение. Элементы упорядочены по ключу. Доступ к элементам производится через ключ. 
Queue – класс коллекции, реализующий модель FIFO (первым пришел – первым ушел). 
Stack – класс коллекции, реализующий модель LIFO (последним пришел – первым вышел). 
SortedList – класс коллекции, дополняющий функциональность типа List возможностью реализовать свой механизм сортировки путем реализации класса интерфейса IComparer. 

Любой из типов, перечисленных выше применяется в случае, если все элементы коллекции одного типа данных.

Обобщенные коллекции
Классы обобщенных коллекций определены в пространстве имен System.Collections библиотеки базовых типов. Самые часто используемые представлены в списке ниже:

Queue - класс коллекции, реализующий модель FIFO (первым пришел – первым ушел)
Stack – класс коллекции, реализующий модель LIFO (последним пришел – первым вышел)
ArrayList – динамический массив, способен увеличивать размер при добавлении нового элемента. 
HashTable – класс коллекции, в основе которой лежат пара ключ/значение. Значения упорядочены по хэш-коду. 



Queue
	Enqueue(T)	Adds an item into the queue.
	Dequeue	Returns an item from the beginning of the queue and removes it from the queue.
	Peek(T)	Returns an first item from the queue without removing it.
	Contains(T)	Checks whether an item is in the queue or not
	Clear()	Removes all the items from the queue.

Stack
	Push(T)	Inserts an item at the top of the stack.
	Peek()	Returns the top item from the stack.
	Pop()	Removes and returns items from the top of the stack.
	Contains(T)	Checks whether an item exists in the stack or not.
	Clear()	Removes all items from the stack.



Array vs ArrayList

	Array Declaration & Initialization:
	int[] arr = new int[5]
	int[] arr = new int[5]{1, 2, 3, 4, 5};
	int[] arr = {1, 2, 3, 4, 5};	

	ArrayList Declaration & Initialization:
	ArrayList arList = new ArrayList();
	arList.Add(1);
	arList.Add("Two");
	arList.Add(false);

	Array stores a fixed number of elements. The size of an Array must be specified at the time of initialization.	
	ArrayList grows automatically and you don't need to specify the size.

	Array is strongly typed. This means that an array can store only specific type of items\elements.	
	ArrayList can store any type of items\elements.

	No need to cast elements of an array while retrieving because it is strongly typed and stores a specific type of items only.	
	The items of ArrayList need to be cast to an appropriate data type while retrieving. So, boxing and unboxing happens.

	Array Performs faster than ArrayList because it is strongly typed.	
	ArrayListPerforms slows because of boxging and unboxing.


Hashtable vs Dictionary
	Hashtable is included in the System.Collections namespace.	
	Dictionary is included in the System.Collections.Generic namespace.

	Hashtable is a loosely typed (non-generic) collection, this means it stores key-value pairs of any data types.	
	Dictionary is a generic collection. So it can store key-value pairs of specific data types.

	Hashtable is thread safe.
	Only public static members are thread safe in Dictionary.

	Hashtable returns null if we try to find a key which does not exist.	
	Dictionary throws an exception if we try to find a key which does not exist.

	Data retrieval is slower than dictionary because of boxing-unboxing.	
	Data retrieval is faster than Hashtable.




Приколы с Dictionary


использовать пользовательский класс  как ключ в Dictionary. Что для этого надо поменять (добавить) в классе?

override GetHashCode  and Equals

class Foo 
{ 
    public string Name { get; set;} 
    public int FooID {get; set;}

    public override int GetHashCode()             
    {  
           return FooID; 
    }

    public override bool Equals(object obj) 
    { 
             return Equals(obj as Foo); 
    }

    public bool Equals(Foo obj)
     { 
          return obj != null && obj.FooID == this.FooID; 
     }
}




++++++++++++++++++++++++++++++++++++++++++++


ASP NET

Ковейер и middleware

Компоненты конвейера, которые отвечают за обработку запроса, называются middleware. 
Для подключения компонентов middleware используется метод Configure из класса Startup. 
Компоненты middleware конфигурируются с помощью методов расширений Run, Map и Use объекта IApplicationBuilder, который передается в метод Configure() класса Startup


Свой middleware
Класс middleware должен иметь конструктор, который принимает параметр типа RequestDelegate. Через этот параметр можно получить ссылку следующий мидлвеер.

Также в классе должен быть определен метод, который должен называться либо Invoke, либо InvokeAsync. Причем этот метод должен возвращать объект Task и принимать в качестве параметра контекст запроса - объект HttpContext. Данный метод собственно и будет обрабатывать запрос.

public class TokenMiddleware
{
    private readonly RequestDelegate _next;
 
    public TokenMiddleware(RequestDelegate next)
    {
        this._next = next;
    }
 
    public async Task InvokeAsync(HttpContext context)
    {
        var token = context.Request.Query["token"];
        if (token!="12345678")
        {
            context.Response.StatusCode = 403;
            await context.Response.WriteAsync("Token is invalid");
        }
        else
        {
            await _next.Invoke(context);			<---------- Вызов следующего мидлвеера
        }
    }
}



public class Startup
{
    public void Configure(IApplicationBuilder app)
    {
        app.UseMiddleware<TokenMiddleware>();		<------------- добавление в пайплайн
 
        app.Run(async (context) =>
        {
            await context.Response.WriteAsync("Hello World");
        });
    }
}




Сервисы MVC

AddMvc(): добавляет все сервисы фреймворка MVC (в том числе сервисы для работы с аутентификацией и авторизацией, валидацией и т.д.)

AddMvcCore(): добавляет только основные сервисы фреймворка MVC, 
а всю допалнительную функциональность, типа аутентификацией и авторизацией, валидацией и т.д., необходимо добавлять самостоятельно

AddControllersWithViews(): позволяет использовать контроллеры и представления и связанную функциональность.
При создании проекта по типу Web Application (Model-View-Controller) используется именно этот метод

AddControllers(): позволяет использовать контроллеры, но без представлений.






++++++++++++++++++++++++++++++++++++++++++++




Жизненный цикл зависимостей
Transient: при каждом обращении к сервису создается новый объект сервиса. В течение одного запроса может быть несколько обращений к сервису, соответственно при каждом обращении будет создаваться новый объект. Подобная модель жизненного цикла наиболее подходит для легковесных сервисов, которые не хранят данных о состоянии

Scoped: для каждого запроса создается свой объект сервиса. То есть если в течение одного запроса есть несколько обращений к одному сервису, то при всех этих обращениях будет использоваться один и тот же объект сервиса.

Singleton: объект сервиса создается при первом обращении к нему, все последующие запросы используют один и тот же ранее созданный объект сервиса




++++++++++++++++++++++++++++++++++++++++++++




Свой обработчик маршрутов

app.UseMvc(routes =>
    {
        routes.MapRoute("api/get", async context =>
        {
            await context.Response.WriteAsync("для обработки использован маршрут api/get");
        });

        routes.MapRoute(
            name: "default",
            template: "{controller=Home}/{action=Index}/{id?}");
    });





Атрибуты NonController, ActionName и NonAction
Eсть класс в папке Controllers, но мы не хотим, чтобы он мог обрабатывать запрос и использоваться как контроллер. 
Чтобы указать, что этот класс не является контроллером, нам надо использовать над ним атрибут [NonController]:

[NonController]
public class HomeController : Controller
{
    //...........
}

Аналогично, если мы хотим, чтобы какой-либо публичный метод контроллера не рассматривался как действие, то мы можем использовать над ним атрибут NonAction:
[NonAction]
public string Hello()
{
    return "Hello ASP.NET";
}
Атрибут [ActionName] позволяет для метода задать другое имя действия. Например:

[ActionName("Welcome")]
public string Hello()
{
    return "Hello ASP.NET";
}
В этом случае чтобы обратиться к этому методу, надо отправить запрос 
localhost:xxxx/Home/Welcome. А запрос localhost:xxxx/Home/Hello работать не будет.




++++++++++++++++++++++++++++++++++++++++++++




IActionResult

Объекты типа IActionResult непосредственно предназначены для генерации результата действия. 
Интерфейс IActionResult находится в пространстве имен Microsoft.AspNetCore.Mvc и определяет один метод:

public interface IActionResult
{
    Task ExecuteResultAsync(ActionContext context);
}

Свой ActionResult
public class HtmlResult : IActionResult
{
    string htmlCode;
    public HtmlResult(string html)
    {
        htmlCode = html;
    }
    public async Task ExecuteResultAsync(ActionContext context)
    {
        string fullHtmlCode = "<!DOCTYPE html><html><head>";
        fullHtmlCode += "<title>Главная страница</title>";
        fullHtmlCode += "<meta charset=utf-8 />";
        fullHtmlCode += "</head> <body>";
        fullHtmlCode += htmlCode;
        fullHtmlCode += "</body></html>";
        await context.HttpContext.Response.WriteAsync(fullHtmlCode);
    }
}




++++++++++++++++++++++++++++++++++++++++++++




Добавление контекста базы данных
public void ConfigureServices(IServiceCollection services)
{
    // получаем строку подключения из файла конфигурации
    string connection = Configuration.GetConnectionString("DefaultConnection");
    // добавляем контекст MobileContext в качестве сервиса в приложение
    services.AddDbContext<ApplicationContext>(options =>
        options.UseSqlServer(connection));
    services.AddControllersWithViews();
}







++++++++++++++++++++++++++++++++++++++++++++




Фильтры

IAuthorizationFilter
	Запускается первым из всех. Проверяет, есть ли у юзера все права для доступа к методу. (проверяет авторизацию)

IResourceFilter
	wЗапускается вторым.
	Методы
	OnResourceExecuting - код в нем запустится после AuthorizationFilter, но до других фильтров.
	OnResourceExecuted - выполнится последним, после выполнения всего пайплайна приложения. 

IActionFilter
	OnActionExecuting - вызвется во время выполнения Action-а
	OnActionExecuted - после выполнения

IPageFilter

IExceptionFilter
	Фильтрует ошибки до того, как они заносятся в тело ответа.
	Может отловить все ошибки кроме авторизационных.

IResultFilter
	Запускается сразу до и после Action метода.
	Сам фильтр запускается только если Action метод выполнен успешно

Глобальные фильтры выполняются первыми (заданные в Startup), 
затем фильтры контроллера,
затем фильтры Action-а 


Для смены очередности фильтров, необходимо в фильтре реализовать интерфейс IOrderedFilter
В нем public int Order => <номер>


Свой фильтр

public class SimpleResourceFilter : Attribute, IResourceFilter
{
    public void OnResourceExecuting(ResourceExecutingContext context)
    {
	var a = context.ActionArguments["name"];
	if (a == "test")
		<do something>
	context.HttpContext.Response.Cookies.Append("LastVisit", DateTime.Now.ToString("dd/MM/yyyy hh-mm-ss"));
    }

    public void OnResourceExecuted(ResourceExecutedContext context)
    {
        // реализация отсутствует
    }
}


Глобальные фильтры
public void ConfigureServices(IServiceCollection services)
{
    // глобально - все сервисы MVC - и контроллеры, и Razor Page
    services.AddMvc(options =>
    {
        options.Filters.Add(typeof(SimpleResourceFilter)); // подключение по типу
         
        // альтернативный вариант подключения
        //options.Filters.Add(new SimpleResourceFilter()); // подключение по объекту
    });
}



Установка отдельно для контроллеров:
public void ConfigureServices(IServiceCollection services)
{
    services.AddControllersWithViews(options=>
    { 
        options.Filters.Add(new SimpleResourceFilter());    // подключение по объекту
        options.Filters.Add(typeof(SimpleResourceFilter));  // подключение по типу
    });
}




Чтобы прервать пайплайн фильтров, надо присвоить значение Result
public void OnResourceExecuting(ResourceExecutingContext context)
{
    context.Result = new ContentResult { Content = "Ресурс не найден" };
}


Фильтр vs Мидлвеер

Middleware operate on the level of ASP.NET Core and can act on every single request that comes in to the application.

MVC filters on the other hand only run for requests that come to MVC.



++++++++++++++++++++++++++++++++++++++++++++



FluentAPI + EF

public class ApplicationContext : DbContext
{
	public ApplicationContext()
	{
	    Database.EnsureDeleted();   // удаляем бд со старой схемой
	    Database.EnsureCreated();   // создаем бд с новой схемой
	}
}



_____________________________TABLES
[Table("People")]
public class User

||

protected override void OnModelCreating(ModelBuilder modelBuilder)
{
    modelBuilder.Entity<User>().ToTable("People");
}




_____________________________COLUMNS

public class User
{
    [Column("user_id")]
    public int Id { get; set; }
}

||

protected override void OnModelCreating(ModelBuilder modelBuilder)
{
	modelBuilder.Entity<User>().Property(u=>u.Id).HasColumnName("user_id");
}




_____________________________PRIMARY KEY

protected override void OnModelCreating(ModelBuilder modelBuilder)
{
    modelBuilder.Entity<User>().HasKey(u => u.Id).HasName("UsersPrimaryKey");
}

[DatabaseGenerated(DatabaseGeneratedOption.Identity)]
public int Id { get; set; }





_____________________________ ALTERNATE KEY = <SQL> UNIQUE
protected override void OnModelCreating(ModelBuilder modelBuilder)
{
    modelBuilder.Entity<User>().HasAlternateKey(u => u.Passport);
}


	


_____________________________ INDEX
protected override void OnModelCreating(ModelBuilder modelBuilder)
{
    modelBuilder.Entity<User>()
        .HasIndex(u => u.PhoneNumber)
        .HasDatabaseName("PhoneIndex");
        //.HasFilter("[PhoneNumber] IS NOT NULL");
}
или

[Index("PhoneNumber", IsUnique =true, Name ="Phone_Index")]
public class User
{
    public int Id { get; set; }
    public string Name { get; set; }
    public string Passport { get; set; }
    public string PhoneNumber { get; set; }
}


There can be only one clustered index per table. 
However, you can create multiple non-clustered indexes on a single table.

Clustered indexes only sort tables and they do not consume extra storage. 
Non-clustered indexes are stored in a separate place from the actual table claiming more storage space.

Clustered indexes are faster than non-clustered indexes since they don’t involve any extra lookup step.







_____________________________ DEFAULT VALUES
protected override void OnModelCreating(ModelBuilder modelBuilder)
{
    modelBuilder.Entity<User>()
        .Property(u => u.CreatedAt)
        .HasDefaultValueSql("GETDATE()");
}

protected override void OnModelCreating(ModelBuilder modelBuilder)
{
    modelBuilder.Entity<User>()
            .Property(u => u.Name)
            .HasComputedColumnSql("[FirstName] + ' ' + [LastName]");
}





_____________________________ FOREIGN KEYS
protected override void OnModelCreating(ModelBuilder modelBuilder)
{
    modelBuilder.Entity<User>()
        .HasOne(p => p.Company)
        .WithMany(t => t.Users)
        .HasForeignKey(p => p.CompanyName)
        .HasPrincipalKey(t=>t.Name);






_____________________________ CASCADE DELETE
public class User
{
    public int Id { get; set; }
    public string Name { get; set; }
 
    public int? CompanyId { get; set; } // внешний ключ               <-------
    public Company Company { get; set; }    // навигационное свойство
}


protected override void OnModelCreating(ModelBuilder modelBuilder)
{
    modelBuilder.Entity<User>()
        .HasOne(p => p.Company)
        .WithMany(t => t.Users)
        .OnDelete(DeleteBehavior.Cascade);		//<----------------
}
// Cascade: зависимая сущность удаляется вместе с главной
// SetNull: свойство-внешний ключ в зависимой сущности получает значение null
// Restrict: зависимая сущность никак не изменяется при удалении главной сущности





_____________________________ СЛОЖНЫЕ СТРУКТУРЫ
var users = db.Users
    .Include(u => u.Company)  // добавляем данные по компаниям
        .ThenInclude(comp => comp.Country)      // к компании добавляем страну 
            .ThenInclude(count => count.Capital)    // к стране добавляем столицу
    .Include(u => u.Position) // добавляем данные по должностям
    .ToList();





_____________________________ OWNED
public class User
{
    public int Id { get; set; }
    public string Login { get; set; }
    public string Password { get; set; }
    public UserProfile Profile { get; set; }
}
[Owned]
public class UserProfile
{
    public string Name { get; set; }
    public int Age { get; set; }
}

//будет таблица
CREATE TABLE [dbo].[Users] (
    [Id]           INT            IDENTITY (1, 1) NOT NULL,
    [Login]        NVARCHAR (MAX) NULL,
    [Password]     NVARCHAR (MAX) NULL,
    [Profile_Name] NVARCHAR (MAX) NULL,						<===========
    [Profile_Age]  INT            NULL,						<===========
    CONSTRAINT [PK_Users] PRIMARY KEY CLUSTERED ([Id] ASC)
);


//FluentAPI
protected override void OnModelCreating(ModelBuilder modelBuilder)
{
    modelBuilder.Entity<User>().OwnsOne(u => u.Profile);
}





_____________________________ JOIN
var users = db.Users.Join(db.Companies, // второй набор
    u => u.CompanyId, // свойство-селектор объекта из первого набора
    c => c.Id, // свойство-селектор объекта из второго набора
    (u, c) => new // результат
    {
        Name=u.Name, 
        Company = c.Name, 
        Age=u.Age
    });



SQL в EF

var comps = db.Companies.FromSqlRaw("SELECT * FROM Companies").ToList();
foreach (var company in comps)
    Console.WriteLine(company.Name);


Интерполяция
var name = "%Tom%";
var age = 30;
var users = db.Users.FromSqlInterpolated($"SELECT * FROM Users WHERE Name LIKE {name} AND Age > {age}").ToList();


Удаление/вставка/апдейт

string newComp = "Apple";
int numberOfRowInserted = db.Database.ExecuteSqlRaw("INSERT INTO Companies (Name) VALUES ({0})", newComp);



EntityState.Modified
Если объект получен в другом контексте
using (PhoneContext db = new PhoneContext())
{
    if(p1!=null)
    {
        p1.Price = 60000;
        db.Entry(p1).State = EntityState.Modified;
        db.SaveChanges();
    }
}

using (PhoneContext db = new PhoneContext())
{
    if(p1!=null)
    {
        db.Entry(p1).State = EntityState.Deleted;
        db.SaveChanges();
    }
}






Stored procedures

public class ApplicationContext : DbContext
{
    public DbSet<Company> Companies { get; set; }
    public DbSet<User> Users { get; set; }
    public IQueryable<User> GetUsersByAge(int age)  => FromExpression(() => GetUsersByAge(age));         <----------
    protected override void OnConfiguring(DbContextOptionsBuilder optionsBuilder)
    {
        optionsBuilder.UseSqlServer(@"Server=(localdb)\mssqllocaldb;Database=helloappdb;Trusted_Connection=True;");
    }
    protected override void OnModelCreating(ModelBuilder modelBuilder)
    {
        modelBuilder.HasDbFunction(() => GetUsersByAge(default));										<------------
    }
}



Типы загрузки: lazy, eager, explicit



Отложенная загрузка (lazy loading) заключается в том, что Entity Framework автоматически загружает данные, 
при этом не загружая связанные данные. Когда потребуются связанные данные, необходимо создасть еще один запрос к базе данных. 

DbContext.Configuration.LazyLoadingEnabled  - по умолчанию

public static void LazyLoading()
{
    SampleContext context = new SampleContext();

    context.Database.Log = (s => System.Diagnostics.Debug.WriteLine(s));

    // Загрузить всех покупателей
    List<Customer> customers = context.Customers 				<--------------
         .ToList();      // +1 запрос к базе

    // Загрузить все их заказы
    List<Order> orders = customers.SelectMany(c => c.Orders)	<--------------
         .ToList();      // +3 запроса к базе данных
}

Прямая загрузка данных (eager loading) позволяет указать в запросе какие связанные данные нужно загрузить при выполнении запроса. 
Благодаря этому, когда в коде вы будете ссылаться на связанную таблицу через навигационное свойство, SQL-запрос не будет направляться 
в базу данных, т.к. связанные данные уже будут загружены при первом запросе. 
В Entity Framework для этих целей используется метод Include(), в котором можно указать навигационное свойство

public static void EagerLoading()
{
    SampleContext context = new SampleContext();

    context.Database.Log = (s => System.Diagnostics.Debug.WriteLine(s));

    // Загрузить всех покупателей и связанные с ними заказы
    List<Customer> customers = context.Customers
        .Include(c => c.Orders)
        .ToList();      // +1 запрос к базе

    // Получить все их заказы
    List<Order> orders = customers.SelectMany(c => c.Orders)
        // Запрос к базе данных не выполняется,
        // т.к. данные уже были извлечены 
        // ранее с помощью прямой загрузки
        .ToList();
}


явная загрузка (explicit loading) данных, не приводит к загрузке всех связанных данных в первом запросе и не приводит к автоматическому 
извлечению связанных данных, вы должны явно вызвать метод Load(), если хотите загрузить связанные данные. Использовать если отключена Lazy Loading и неизвестно, будут ли использоваться связанные данные.


virtual needed only if you want lazy loading support



++++++++++++++++++++++++++++++++++++++++++++


SQL

Create
Drop
Alter
Update


DROP TABLE <table_name>

#Alter
ALTER TABLE <t_name> ADD <col_name> <data_type>
					 DROP column <col_name>
					 ALTER COLUMN <col_name> <data_type>
					 ADD CONSTRAINT


#Create
CREATE TABLE Odrers
(
	order_id INT PRIMARY KEY,
	prod_id INT NOT NULL,
	quantity INT,

		CONSTRAINT fr_prod_id
		FOREIGN KEY (prod_id)
		REFERENCES product (prod_id)
#			on DELETE CASCADE
);


#VIEW

CREATE VIEW VW_Odreds AS
SELECT * FROM Odrers; 

INSERT INTO t_name (col_1, col_2) AS 
SELECT name_1, name_2 FROM t_name2;


UPDATE t_name SET col_Name='New Name', col_Name_2 = 'New Name 2' WHERE id=1 
я



#SELF JOIN
Обязательно дать элиасы таблицам

#CROSS JOIN
каждая строка к каждой строке (5 строк в 1 таблице, 6 во второй => 30 строк в итоге)

#PROCEDURES

CREATE PROCEDURE p_name
@Param 	nvarchar(20)
AS
SELECT * FROM t_name
WHERE id = @Param
#GO - чтобы убедиться, что код выше выполнен

EXEC p_name @Param = 5


#INDEX
CREATE INDEX index_name
ON t_name(col_name1, col_name2)

#Много времени на создание


#TRANSACTION

CREATE PROCEDURE p_name
@Param 	nvarchar(20)
AS
BEGIN TRY
	BEGIN TRANSACTION

	<SELECT, INSERT, UPDATE...>

	COMMIT TRANSACTION
END TRY

BEGIN CATCH
	ROLLBACK TRANSACTION
END CATCH

SELECT * FROM t_name
WHERE id = @Param


наекластерный индекс - отдельная таблица, каждая строка в которой ссылается на одну или несколько строк в таблице с данными. Строки в индексной таблице упорядочены и сгруппированы по значениям ключевых полей.

Плюсы
задача поиска сильно ускоряется. 
Во-первых, индексная таблица весит много меньше таблицы с данными, а значит элементарно может быть прочитана быстрее. 
Во-вторых, СУБД чаще всего стараются кешировать индексы в оперативную память, которая сама по себе много шустрее жёсткого диска*. 
В-третьих, в индексах отсутствуют дублирующиеся строки. А значит, как только мы нашли первое значение, поиск можно прекращать — оно же и последнее. 
В-четвёртых, данные в индексе отсортированы. 
А в-третьих и в-четвёртых вместе позволяют использовать алгоритм бинарного поиска (он же метод деления пополам), эффективность которого многократно превосходит простой перебор.

Кластерный индекс — это древовидная структура данных, при которой значения индекса хранятся вместе с данными, им соответствующими. И индексы, и данные при такой организации упорядочены. При добавлении новой строки в таблицу, она дописывается не в конец файла*, не в конец плоского списка, а в нужную ветку древовидной структуры, соответствующую ей по сортировке.



++++++++++++++++++++++++++++++++++++++++++++


DI

Construction Injection
Setter Injection
Interface based Injection.



Construction Injection
Зависимости нужны на этапе создания, чтобы проинициализировать объекты. Т.е. конструктор использует параметры для внедрения зависимостей.

Плюсы/минусы

зависимость можно сделать immutable (неизменяемой), чтобы предотвратить повторное внедрение зависимости
все зависимости должны быть переданы в конструкторе


Setter Injection

Для внедрения сложных зависимостей в указанный момент

Плюсы/минусы

не нужно все прописывать в конструкторе
всегда надо отслеживать, какая зависимость нужна, чтоб подгрузить ее


Interface Based Injection



++++++++++++++++++++++++++++++++++++++++++++
