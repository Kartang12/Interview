Модификаторы доступа:

public: 
публичный, общедоступный класс или член класса. Такой член класса доступен из любого места в коде, а также из других программ и сборок.

private:
закрытый класс или член класса. Представляет полную противоположность модификатору public. Такой закрытый класс или член класса доступен только из кода в том же классе или контексте.

protected: 
такой член класса доступен из любого места в текущем классе или в производных классах. При этом производные классы могут располагаться в других сборках.

internal: 
класс и члены класса  доступны из любого места кода в той же сборке, однако он недоступен для других программ и сборок (как в случае с модификатором public).

protected internal: 
совмещает функционал двух модификаторов. Классы и члены класса доступны из текущей сборки и из производных классов В другой сборке.

private protected: 
такой член класса доступен из любого места в текущем классе или в производных классах, которые определены в той же сборке.

file




Раннее связывание – связанное с формированием кода на этапе компиляции. При раннем связывании, программный код формируется на основе известной информации о типе (класс) ссылки. Как правило, это ссылка на базовый класс в иерархии классов.
Позднее связывание – связанное с формированием кода на этапе выполнения. Если в иерархии классов встречается цепочка виртуальных методов (с помощью слов virtual, override), то компилятор строит так называемое позднее связывание. При позднем связывании вызов метода происходит на основании типа объекта, а не типа ссылки на базовый класс. Позднее связывание используется, если нужно реализовать полиморфизм.


Сокрытие если
метод в базовом классе не является виртуальным, мы не можем его переопределить, но нас не устраивает его реализация для производного класса

Переопределение (virtual)

Person tom = new Employee("Tom", "Microsoft");
tom.Display(); 
вызове tom.Display() выполняется реализация метода Display из класса Employee.

Сокрытие
при вызове метода Display будет выполняться та версия метода, которая определена именно в классе Person, а не в классе Employee.





S: Single Responsibility Principle (Принцип единственной ответственности).
Каждый класс должен решать лишь одну задачу.

O: Open-Closed Principle (Принцип открытости-закрытости).
Программные сущности (классы, модули, функции) должны быть открыты для расширения, но не для модификации.

L: Liskov Substitution Principle (Принцип подстановки Барбары Лисков).
Необходимо, чтобы подклассы могли бы служить заменой для своих суперклассов.

I: Interface Segregation Principle (Принцип разделения интерфейса).
Создавайте узкоспециализированные интерфейсы, предназначенные для конкретного клиента. Клиенты не должны зависеть от интерфейсов, которые они не используют.

D: Dependency Inversion Principle (Принцип инверсии зависимостей).
Объектом зависимости должна быть абстракция, а не что-то конкретное.




интернирование строк - это процесс, при котором ссылки одинаковых строк сливаются воедино, и в результате у нас , фактически, из нескольких строк получается одна


Полиморфиз/Наследование

Ad-hoc полифорфизм (перегрузка функций, приведение типа) — можно создать несколько методов с одним именем и разными аргументами, примитивные типы могут неявно приводиться.

Параметрический полиморфизм (обобщённое программирование) — Collection<T> можно создать полиморфные (обобщённые) типы.

Полиморфизм включения (наследование) — поддерживается, есть интерфейсы, наследование классов, одиночная и множественная диспетчеризация. Примитивные типы неполиморфны.

для вызова метода в языке CIL среды CLR, есть три инструкции: call, calli и callvirt. Последняя инструкция реализует принцип позднего связывания. То есть, говоря простым языком, решение о вызове определённого метода принимается во время выполнения, а не компиляции. Тем самым реализуется идея полиморфизма. 

===============================


Если класс объявлен с модификатором sealed, то от этого класса нельзя наследовать и создавать производные классы.

Нельзя унаследовать класс от статического класса.